name: Deploy Website

on:
  push:
    branches: [ main, dev ]
    paths-ignore:
      - 'README.md'
      - '.github/**'

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Determine deployment environment
      id: env
      run: |
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "ENVIRONMENT=production" >> $GITHUB_OUTPUT
          echo "STACK_FILE=docker-stack-traefik.yml" >> $GITHUB_OUTPUT
          echo "STACK_NAME=renekris-stack" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=renekris-web" >> $GITHUB_OUTPUT
          echo "HOST_HEADER=renekris.dev" >> $GITHUB_OUTPUT
        else
          echo "ENVIRONMENT=staging" >> $GITHUB_OUTPUT
          echo "STACK_FILE=docker-stack-staging.yml" >> $GITHUB_OUTPUT
          echo "STACK_NAME=renekris-staging" >> $GITHUB_OUTPUT
          echo "SERVICE_NAME=renekris-staging" >> $GITHUB_OUTPUT
          echo "HOST_HEADER=staging.renekris.dev" >> $GITHUB_OUTPUT
        fi
    
    - name: Deploy to ${{ steps.env.outputs.ENVIRONMENT }}
      run: |
        cd /opt/renekris-infrastructure
        echo "üöÄ Starting automated deployment to ${{ steps.env.outputs.ENVIRONMENT }}..."
        echo "üì¶ Building Docker image for branch: ${{ github.ref_name }}"
        
        # Generate unique build identifier
        TIMESTAMP_ID="$(date +%s)"
        BUILD_ID="${{ github.ref_name }}-${TIMESTAMP_ID}"
        COMMIT_HASH="${{ github.sha }}"
        
        # Build Docker image with consistent naming (renekris-web not renekris-website)
        cd /opt/renekris-dev-website
        docker build -t renekris-web:${BUILD_ID} .
        
        # Generate stack file with dynamic image tag
        cd /opt/renekris-infrastructure
        ./generate-stack-files.sh ${{ steps.env.outputs.ENVIRONMENT }} ${{ github.ref_name }} ${TIMESTAMP_ID}
        
        echo "üîÑ Deploying with image: renekris-web:${BUILD_ID}"
        
        # Deploy using generated stack file
        docker stack deploy -c ${{ steps.env.outputs.STACK_FILE }} ${{ steps.env.outputs.STACK_NAME }}
        
        echo "üìù Deployment completed with image tag: ${BUILD_ID}"
    
    - name: Verify ${{ steps.env.outputs.ENVIRONMENT }} deployment
      run: |
        echo "üîç Verifying deployment to ${{ steps.env.outputs.ENVIRONMENT }}..."
        
        # Wait for service to stabilize
        echo "‚è≥ Waiting for services to stabilize..."
        sleep 15
        
        # Check container status
        echo "üìã Container Status:"
        docker ps --filter name=${{ steps.env.outputs.SERVICE_NAME }} --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
        
        # Test health endpoint
        echo "üè• Testing health endpoint..."
        if curl -f -H 'Host: ${{ steps.env.outputs.HOST_HEADER }}' http://localhost/health > /dev/null; then
          echo "‚úÖ Health check passed"
        else
          echo "‚ùå Health check failed"
          exit 1
        fi
        
        # Test main page and check for build timestamp
        echo "üåê Testing main page and content freshness..."
        RESPONSE=$(curl -s -k -H 'Host: ${{ steps.env.outputs.HOST_HEADER }}' https://localhost/)
        
        if echo "$RESPONSE" | grep -q "<!DOCTYPE html"; then
          echo "‚úÖ Main page is accessible and returns HTML"
        else
          echo "‚ùå Main page is not accessible or not returning HTML"
          exit 1
        fi
        
        # Check if build timestamp header is present (cache busting verification)
        BUILD_TIMESTAMP=$(curl -s -I -k -H 'Host: ${{ steps.env.outputs.HOST_HEADER }}' https://localhost/ | grep -i "x-build-timestamp" | cut -d' ' -f2- | tr -d '\r')
        
        if [ -n "$BUILD_TIMESTAMP" ]; then
          echo "‚úÖ Build timestamp header found: $BUILD_TIMESTAMP"
          echo "   This confirms cache busting is working"
        else
          echo "‚ö†Ô∏è  No build timestamp header found (this is expected for production)"
        fi
        
        # Verify Docker service is using the correct image
        if [ "${{ steps.env.outputs.ENVIRONMENT }}" = "staging" ]; then
          DEPLOYED_IMAGE=$(docker service inspect renekris-staging_web-staging --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null)
        else
          DEPLOYED_IMAGE=$(docker service inspect renekris-stack_web --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null)
        fi
        
        if echo "$DEPLOYED_IMAGE" | grep -q "renekris-web:"; then
          echo "‚úÖ Service is using correct image: $DEPLOYED_IMAGE"
        else
          echo "‚ö†Ô∏è  Could not verify deployed image or image format unexpected"
        fi
        
        echo ""
        echo "üéâ Deployment to ${{ steps.env.outputs.ENVIRONMENT }} completed successfully!"
        echo "üìä Deployment Summary:"
        echo "   Environment: ${{ steps.env.outputs.ENVIRONMENT }}"
        echo "   Host: ${{ steps.env.outputs.HOST_HEADER }}"
        echo "   Image: renekris-web:${{ github.ref_name }}-$(date +%s)"
        echo "   Status: ‚úÖ VERIFIED"